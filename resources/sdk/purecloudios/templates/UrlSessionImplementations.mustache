// UrlSessionImplementations.swift
//
// Generated by swagger-codegen
// https://github.com/swagger-api/swagger-codegen
//

import Foundation

class UrlSessionRequestBuilderFactory: RequestBuilderFactory {
    func getBuilder<T>() -> RequestBuilder<T>.Type {
        return UrlSessionRequestBuilder<T>.self
    }
}

open class UrlSessionRequestBuilder<T>: RequestBuilder<T> {
    private let jsonDecoder: JSONDecoder = {
        let jsonDecoder = JSONDecoder()
        jsonDecoder.keyDecodingStrategy = .convertFromSnakeCase

        let formatter = DateFormatter()
        formatter.calendar = Calendar(identifier: .iso8601)
        formatter.locale = Locale(identifier: "en_US_POSIX")
//        formatter.timeZone = TimeZone(abbreviation: "UTC")

        // https://www.hackingwithswift.com/articles/119/codable-cheat-sheet
        jsonDecoder.dateDecodingStrategy = .custom { (jsonDecoder) -> Date in
            let container = try jsonDecoder.singleValueContainer()
            let dateStr = try container.decode(String.self)

            formatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ss.SSSXXXXX"
            if let date = formatter.date(from: dateStr) {
                return date
            }
            formatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ssXXXXX"
            if let date = formatter.date(from: dateStr) {
                return date
            }
            throw ApiError.invalidDate
        }

//        jsonDecoder.dateDecodingStrategy = .iso8601

        return jsonDecoder
    }()

    public required init(method: String, url: URLComponents, body: Data?, headers: [String: String] = [:]) {
        super.init(method: method, url: url, body: body, headers: headers)
    }

    open override func executeVoid(_ completion: @escaping (_ response: Response<T>?, _ error: Error?) -> Void) {
        let session = URLSession(configuration: .default)

        switch method {
        case "GET":
            var request = URLRequest(url: url.url!)

            // Set headers
            for (key, value) in headers {
                request.setValue(value, forHTTPHeaderField: key)
            }

            // Create completion handler
            let completionHandler = { (data: Data?, response: URLResponse?, error: Error?) in
                // Handle Error
                if let error = error {
                    completion(
                        nil,
                        ApiError.generalError(error)
                    )
                    return
                }

                // Handle Empty Response
                guard let response = response as? HTTPURLResponse else {
                    completion(
                        nil,
                        ApiError.emptyResponse
                    )
                    return
                }

                // Handle Empty Data
                guard let data = data else {
                    completion(
                        Response(
                            response: response,
                            body: nil
                        ),
                        nil
                    )
                    return
                }

                // success
                do {
                    completion(
                        Response(
                            response: response,
                            body: nil
                        ),
                        nil
                    )
                } catch {
                    completion(
                        nil,
                        ApiError.decoderError(error)
                    )
                }
            }

            // Execute API request
            session.dataTask(with: request, completionHandler: completionHandler).resume()
        default:
            completion(
                nil,
                ApiError.unknownHttpVerb(verb: method)
            )
        }
    }

    open override func execute<T: Decodable>(_ completion: @escaping (_ response: Response<T>?, _ error: Error?) -> Void) {
        let session = URLSession(configuration: .default)

        var request = URLRequest(url: url.url!)

        // Set headers
        for (key, value) in headers {
            request.setValue(value, forHTTPHeaderField: key)
        }

        // Create completion handler
        let completionHandler = { (data: Data?, response: URLResponse?, error: Error?) in
            // Handle Error
            if let error = error {
                completion(
                    nil,
                    ApiError.generalError(error)
                )
                return
            }

            // Handle Empty Response
            guard let response = response as? HTTPURLResponse else {
                completion(
                    nil,
                    ApiError.emptyResponse
                )
                return
            }

            // Handle Empty Data
            guard let data = data else {
                completion(
                    Response(
                        response: response,
                        body: nil
                    ),
                    nil
                )
                return
            }

            // Success
            do {
                let outputStr = String(data: data, encoding: String.Encoding.utf8)
                NSLog("Response string: " + outputStr!)

                let body: T = try self.jsonDecoder.decode(T.self, from: data)

                completion(
                    Response(
                        response: response,
                        body: body
                    ),
                    nil
                )
            } catch {
                completion(
                    nil,
                    ApiError.decoderError(error)
                )
            }
        }

        switch method {
        case "GET":
            request.httpMethod = "GET"
        case "POST":
            request.httpMethod = "POST"
            if let b = self.body {
                request.setValue("application/json", forHTTPHeaderField: "content-type")
                request.setValue("application/json", forHTTPHeaderField: "accept")
                request.httpBody = b
            }
        default:
            completion(
                nil,
                ApiError.unknownHttpVerb(verb: method)
            )
        }

        // Execute API request
        session.dataTask(with: request, completionHandler: completionHandler).resume()
    }

    fileprivate func getFileName(fromContentDisposition contentDisposition: String?) -> String? {
        guard let contentDisposition = contentDisposition else {
            return nil
        }

        let items = contentDisposition.components(separatedBy: ";")

        var filename: String?

        for contentItem in items {
            let filenameKey = "filename="
            guard let range = contentItem.range(of: filenameKey) else {
                break
            }

            filename = contentItem
            return filename?
                .replacingCharacters(in: range, with: "")
                .replacingOccurrences(of: "\"", with: "")
                .trimmingCharacters(in: .whitespacesAndNewlines)
        }

        return filename
    }

    fileprivate func getPath(from url: URL) throws -> String {
        guard var path = URLComponents(url: url, resolvingAgainstBaseURL: true)?.path else {
            throw DownloadException.requestMissingPath
        }

        if path.hasPrefix("/") {
            path.remove(at: path.startIndex)
        }

        return path
    }

    fileprivate func getURL(from urlRequest: URLRequest) throws -> URL {
        guard let url = urlRequest.url else {
            throw DownloadException.requestMissingURL
        }

        return url
    }
}

private enum DownloadException: Error {
    case responseDataMissing
    case responseFailed
    case requestMissing
    case requestMissingPath
    case requestMissingURL
}

public enum ApiError: Error {
    case emptyResponse
    case decoderError(Error)
    case unknownHttpVerb(verb: String)
    case generalError(Error)
    case invalidDate
}