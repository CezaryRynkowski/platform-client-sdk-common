package {{packageName}}

import (
	"crypto/sha256"
	"encoding/base64"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"github.com/spf13/viper"
	"io/ioutil"
	"net/http"
	"net/url"
	"regexp"
	"strings"
	"sync"
	"time"
)

// Configuration has settings to configure the SDK
type Configuration struct {
	UserName                  string              `json:"userName,omitempty"`
	Password                  string              `json:"password,omitempty"`
	APIKeyPrefix              map[string]string   `json:"APIKeyPrefix,omitempty"`
	APIKey                    map[string]string   `json:"APIKey,omitempty"`
	OAuthToken                string              `json:"oAuthToken,omitempty"`
	Timeout                   int                 `json:"timeout,omitempty"`
	BasePath                  string              `json:"basePath,omitempty"`
	Host                      string              `json:"host,omitempty"`
	Scheme                    string              `json:"scheme,omitempty"`
	AccessToken               string              `json:"accessToken,omitempty"`
	RefreshToken              string              `json:"refreshToken,omitempty"`
	ClientID                  string              `json:"clientId,omitempty"`
	ClientSecret              string              `json:"clientSecret,omitempty"`
	ShouldRefreshAccessToken  bool                `json:"shouldRefreshAccessToken,omitempty"`
	RefreshInProgress         int64               `json:"refreshInProgress,omitempty"`
	RefreshTokenWaitTime      int                 `json:"refreshTokenWaitTime,omitempty"`
	DefaultHeader             map[string]string   `json:"defaultHeader,omitempty"`
	UserAgent                 string              `json:"userAgent,omitempty"`
	APIClient                 APIClient           `json:"APIClient,omitempty"`
	RetryConfiguration        *RetryConfiguration `json:"retryConfiguration,omitempty"`
	LoggingConfiguration      *LoggingConfiguration `json:"loggingConfiguration,omitempty"`
	configFileHash            string
	configFilePath            string
	configFileName            string
}

const (
	USEast1      = "https://api.mypurecloud.com"
	EUWest1      = "https://api.mypurecloud.ie"
	APSoutheast2 = "https://api.mypurecloud.com.au"
	APNortheast1 = "https://api.mypurecloud.jp"
	EUCentral1   = "https://api.mypurecloud.de"
	USWest2      = "https://api.usw2.pure.cloud"
	CACentral1   = "https://api.cac1.pure.cloud"
	APNortheast2 = "https://api.apne2.pure.cloud"
	EUWest2      = "https://api.euw2.pure.cloud"
	APSouth1     = "https://api.aps1.pure.cloud"
)

// RetryConfiguration has settings to configure the SDK retry logic
type RetryConfiguration struct {
	RetryWaitMin    time.Duration                `json:"retry_wait_min,omitempty"`
	RetryWaitMax    time.Duration                `json:"retry_wait_max,omitempty"`
	RetryMax        int                          `json:"retry_max,omitempty"`
	RequestLogHook	RequestLogHook               `json:"request_log_hook,omitempty"`
}

type RequestLogHook func(*http.Request, int)

// LoggingConfiguration has settings to configure the SDK logging
type LoggingConfiguration struct {
	LogLevel     LoggingLevel  `json:"logLevel,omitempty"`
	LogFormat    LoggingFormat `json:"logFormat,omitempty"`
	LogFilePath  string        `json:"logFilePath,omitempty"`
	LogToConsole bool          `json:"logToConsole,omitempty"`
}

// AuthResponse contains the access token to use in future requests
type AuthResponse struct {
	AccessToken  string `json:"access_token,omitempty"`
	RefreshToken string `json:"refresh_token,omitempty"`
	TokenType    string `json:"token_type,omitempty"`
	ExpiresIn    int    `json:"expires_in,omitempty"`
}

// AuthErrorResponse gives you some intel when authorization goes boom
type AuthErrorResponse struct {
	Error            string `json:"error,omitempty"`
	Description      string `json:"description,omitempty"`
	ErrorDescription string `json:"error_description,omitempty"`
}

var (
	once sync.Once
	instance *Configuration
)

// GetDefaultConfiguration returns the shared default configuration instance
func GetDefaultConfiguration() *Configuration {
	once.Do(func() {
		instance = NewConfiguration()
	})
	return instance
}

// NewConfiguration returns a new Configuration instance
func NewConfiguration() *Configuration {
	// Make initial Configuration instance with default values
	c := &Configuration{
		BasePath:                 "{{basePath}}",
		UserName:                 "",
		LoggingConfiguration:     &LoggingConfiguration{
			LogLevel:     LNone,
			LogFormat:    Text,
			LogToConsole: true,
		},
		ShouldRefreshAccessToken: true,
		RefreshTokenWaitTime:     10,
		DefaultHeader:            make(map[string]string),
		APIKey:                   make(map[string]string),
		APIKeyPrefix:             make(map[string]string),
		UserAgent:               "{{#httpUserAgent}}{{{.}}}{{/httpUserAgent}}{{^httpUserAgent}}Swagger-Codegen/{{{packageVersion}}}/go{{/httpUserAgent}}",
		configFilePath:           "/Users/ronanwatkins/genesys_src/repos/platform-client-sdk-common/output/purecloudgo/platformclientv2/",
		configFileName:           "config.toml",
	}
	_ = c.initializeConfigFromFile()
	go c.runConfigChecker()

	c.LoggingConfiguration.configureLogging()
	c.APIClient = NewAPIClient(c)
	return c
}

func (c *Configuration) initializeConfigFromFile() error {
	viper.SetConfigName("config")
	viper.SetConfigType("toml")
	viper.AddConfigPath(c.configFilePath)

	if err := c.updateConfigFromFile(); err != nil {
		return err
	}

	return nil
}

func (c *Configuration) updateConfigFromFile() error {
	if err := viper.ReadInConfig(); err != nil {
		return err
	}

	logLevel := getConfigValue("log_level")
	switch logLevel {
	case "trace":
		c.LoggingConfiguration.LogLevel = LTrace
	case "debug":
		c.LoggingConfiguration.LogLevel = LDebug
	case "error":
		c.LoggingConfiguration.LogLevel = LError
	case "none":
		c.LoggingConfiguration.LogLevel = LNone
	}

	logFormat := getConfigValue("log_format")
	switch logFormat {
	case "text":
		c.LoggingConfiguration.LogFormat = Text
	case "json":
		c.LoggingConfiguration.LogFormat = JSON
	}

	logToConsole := getConfigValue("log_to_console")
	switch logToConsole {
	case "true":
		c.LoggingConfiguration.LogToConsole = true
	case "false":
		c.LoggingConfiguration.LogToConsole = false
	}

	logFilePath := getConfigValue("log_file_path")
	if logFilePath != "" {
		c.LoggingConfiguration.LogFilePath = logFilePath
	}

	c.LoggingConfiguration.configureLogging()

	return nil
}

func getConfigValue(key string) string {
	value := viper.GetViper().Get(key)
	if value == nil {
		return ""
	}

	return strings.ToLower(fmt.Sprintf("%s", value))
}

func (c *Configuration) runConfigChecker() {
	for {
		time.Sleep(10 * time.Second) //TODO 30 seconds

		hash, err := getFileHash(fmt.Sprintf("%s%s", c.configFilePath, c.configFileName))
		if err != nil {
			continue
		}
		if hash != c.configFileHash {
			c.configFileHash = hash
			if err := c.updateConfigFromFile(); err != nil {
				continue
			}
		}
	}
}

func getFileHash(filePath string) (string, error) {
	hasher := sha256.New()
	s, err := ioutil.ReadFile(filePath)
	if err != nil {
		return "", err
	}
	hasher.Write(s)

	return hex.EncodeToString(hasher.Sum(nil)), nil
}

// AuthorizeClientCredentials authorizes this Configuration instance using client credentials.
// The access token will be set automatically and API instances using this configuration object can now make authorized requests.
func (c *Configuration) AuthorizeClientCredentials(clientID string, clientSecret string) error {
	authHostRegex := regexp.MustCompile(`(?i)\/\/api\.`)
	authHost := authHostRegex.ReplaceAllString(c.BasePath, "//login.")
	headerParams := make(map[string]string)
	headerParams["Authorization"] = "Basic " + base64.StdEncoding.EncodeToString([]byte(clientID+":"+clientSecret))
	formParams := url.Values{}
	formParams["grant_type"] = []string{"client_credentials"}
	response, err := c.APIClient.CallAPI(authHost+"/oauth/token", "POST", nil, headerParams, nil, formParams, "", nil)
	if err != nil {
		fmt.Println(err)
		return err
	}

	if response.StatusCode != http.StatusOK {
		var authErrorResponse *AuthErrorResponse
		err = json.Unmarshal([]byte(response.RawBody), &authErrorResponse)
		if err != nil {
			return err
		}
		return fmt.Errorf("Auth Error: %v (%v - %v)", authErrorResponse.Description, authErrorResponse.Error, authErrorResponse.ErrorDescription)
	}

	var authResponse *AuthResponse
	err = json.Unmarshal([]byte(response.RawBody), &authResponse)
	if err != nil {
		return err
	}
	c.AccessToken = authResponse.AccessToken
	if c.AccessToken == "" {
		return fmt.Errorf("Auth Error: No access token found")
	}
	
	return nil
}

// AuthorizeCodeGrant authorizes this Configuration instance using an authorization code grant.
// The access and refresh tokens will be set automatically and API instances using this configuration object can now make authorized requests.
func (c *Configuration) AuthorizeCodeGrant(clientID string, clientSecret string, authCode string, redirectUri string) (*AuthResponse, error) {
	c.ClientID = clientID
	c.ClientSecret = clientSecret
	authHostRegex := regexp.MustCompile(`(?i)\/\/api\.`)
	authHost := authHostRegex.ReplaceAllString(c.BasePath, "//login.")
	headerParams := make(map[string]string)
	headerParams["Authorization"] = "Basic " + base64.StdEncoding.EncodeToString([]byte(clientID+":"+clientSecret))
	headerParams["Content-Type"] = "application/x-www-form-urlencoded"
	formParams := url.Values{}
	formParams["grant_type"] = []string{"authorization_code"}
	formParams["code"] = []string{authCode}
	formParams["redirect_uri"] = []string{redirectUri}
	response, err := c.APIClient.CallAPI(authHost+"/oauth/token", "POST", nil, headerParams, nil, formParams, "", nil)
	if err != nil {
		fmt.Println(err)
		return nil, err
	}

	if response.StatusCode != http.StatusOK {
		var authErrorResponse *AuthErrorResponse
		err = json.Unmarshal([]byte(response.RawBody), &authErrorResponse)
		if err != nil {
			return nil, err
		}
		return nil, fmt.Errorf("Auth Error: %v (%v - %v)", authErrorResponse.Description, authErrorResponse.Error, authErrorResponse.ErrorDescription)
	}

	var authResponse *AuthResponse
	err = json.Unmarshal([]byte(response.RawBody), &authResponse)
	if err != nil {
		return nil, err
	}
	c.AccessToken = authResponse.AccessToken
	if c.AccessToken == "" {
		return nil, fmt.Errorf("Auth Error: No access token found")
	}
	c.RefreshToken = authResponse.RefreshToken
	if c.RefreshToken == "" {
		return nil, fmt.Errorf("Auth Error: No refresh token found")
	}

	return authResponse, nil
}

// RefreshAuthorizationCodeGrant requests a new access token for the authorization code grant.
// The access and refresh tokens will be set automatically and API instances using this configuration object can continue to make authorized requests.
func (c *Configuration) RefreshAuthorizationCodeGrant(clientID string, clientSecret string, refreshToken string) (*AuthResponse, error) {
	authHostRegex := regexp.MustCompile(`(?i)\/\/api\.`)
	authHost := authHostRegex.ReplaceAllString(c.BasePath, "//login.")
	headerParams := make(map[string]string)
	headerParams["Authorization"] = "Basic " + base64.StdEncoding.EncodeToString([]byte(clientID+":"+clientSecret))
	headerParams["Content-Type"] = "application/x-www-form-urlencoded"
	formParams := url.Values{}
	formParams["grant_type"] = []string{"refresh_token"}
	formParams["refresh_token"] = []string{refreshToken}
	response, err := c.APIClient.CallAPI(authHost+"/oauth/token", "POST", nil, headerParams, nil, formParams, "", nil)
	if err != nil {
		fmt.Println(err)
		return nil, err
	}

	if response.StatusCode != http.StatusOK {
		var authErrorResponse *AuthErrorResponse
		err = json.Unmarshal([]byte(response.RawBody), &authErrorResponse)
		if err != nil {
			return nil, err
		}
		return nil, fmt.Errorf("Auth Error: %v (%v - %v)", authErrorResponse.Description, authErrorResponse.Error, authErrorResponse.ErrorDescription)
	}

	var authResponse *AuthResponse
	err = json.Unmarshal([]byte(response.RawBody), &authResponse)
	if err != nil {
		return nil, err
	}
	c.AccessToken = authResponse.AccessToken
	if c.AccessToken == "" {
		return nil, fmt.Errorf("Auth Error: No access token found")
	}
	c.RefreshToken = authResponse.RefreshToken
	if c.RefreshToken == "" {
		return nil, fmt.Errorf("Auth Error: No refresh token found")
	}

	return authResponse, nil
}

// AddDefaultHeader sets a header that will be set on every request
func (c *Configuration) AddDefaultHeader(key string, value string) {
	c.DefaultHeader[key] = value
}

// GetAPIKeyWithPrefix appends a prefix to the API key
func (c *Configuration) GetAPIKeyWithPrefix(APIKeyIdentifier string) string {
	if c.APIKeyPrefix[APIKeyIdentifier] != "" {
		return c.APIKeyPrefix[APIKeyIdentifier] + " " + c.APIKey[APIKeyIdentifier]
	}

	return c.APIKey[APIKeyIdentifier]
}
