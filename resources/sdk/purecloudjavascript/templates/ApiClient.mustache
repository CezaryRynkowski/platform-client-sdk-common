(function(root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define(['superagent'], factory);
  } else if (typeof module === 'object' && module.exports) {
    // CommonJS-like environments that support module.exports, like Node.
    module.exports = factory(require('superagent'));
  } else {
    // Browser globals (root is window)
    if (!root.{{moduleName}}) {
      root.{{moduleName}} = {};
    }
    root.{{moduleName}}.ApiClient = factory(root.superagent);
  }
}(this, function(superagent) {
  'use strict';

{{#emitJSDoc}}  /**
   * @module {{#invokerPackage}}{{invokerPackage}}/{{/invokerPackage}}ApiClient
   * @version {{projectVersion}}
   */

  /**
   * Manages low level client-server communications, parameter marshalling, etc. There should not be any need for an
   * application to use this class directly - the *Api and model classes provide the public API for the service. The
   * contents of this file should be regarded as internal but are documented for completeness.
   * @alias module:{{#invokerPackage}}{{invokerPackage}}/{{/invokerPackage}}ApiClient
   * @class
   */
{{/emitJSDoc}}  var exports = function() {
{{#emitJSDoc}}    /**
     * The base URL against which to resolve every API call's (relative) path.
     * @type {String}
     * @default {{basePath}}
     */
{{/emitJSDoc}}    this.setEnvironment('{{basePath}}');

{{#emitJSDoc}}    /**
     * The authentication methods to be included for all API calls.
     * @type {Array.<String>}
     */
{{/emitJSDoc}}{{=< >=}}    this.authentications = {<#authMethods><#isBasic>
      '<name>': {type: 'basic'}</isBasic><#isApiKey>
      '<name>': {type: 'apiKey', 'in': <#isKeyInHeader>'header'</isKeyInHeader><^isKeyInHeader>'query'</isKeyInHeader>, name: '<keyParamName>'}</isApiKey><#isOAuth>
      '<name>': {type: 'oauth2'}</isOAuth><#hasMore>,</hasMore></authMethods>
    };
<={{ }}=>
{{#emitJSDoc}}    /**
     * The default HTTP headers to be included for all API calls.
     * @type {Array.<String>}
     * @default {}
     */
{{/emitJSDoc}}    this.defaultHeaders = {};

    /**
     * The default HTTP timeout for all API calls.
     * @type {Number}
     * @default 60000
     */
    this.timeout = 16000;

    this.settingsPrefix = 'purecloud';

    // Check for auth token in hash
    this._setValuesFromUrlHash();
  };

{{#emitJSDoc}}  /**
   * @description xxx
   * @param {string} xxx - (Optional, default false) xxx
   */
{{/emitJSDoc}}  exports.prototype.setDebugLog = function setDebugLoggingEnabled(debugLog) {
    this.debugLog = debugLog;
  };

{{#emitJSDoc}}  /**
   * @description xxx
   * @param {string} xxx - (Optional, default false) xxx
   */
{{/emitJSDoc}}  exports.prototype.setReturnExtendedResponses = function setReturnExtendedResponses(returnExtended) {
    this.returnExtended = returnExtended;
  };

{{#emitJSDoc}}  /**
   * @description xxx
   * @param {string} xxx - (Optional, default false) xxx
   */
{{/emitJSDoc}}  exports.prototype.setPersistSettings = function setPersistSettings(doPersist, prefix) {
    this.persistSettings = doPersist;
    this.settingsPrefix = prefix ? prefix.replace(/\W+/g, '_') : 'purecloud';
    console.log(`this.settingsPrefix=${this.settingsPrefix}`);
  };

{{#emitJSDoc}}  /**
   * @description xxx
   * @param {string} xxx - (Optional, default false) xxx
   */
{{/emitJSDoc}}  exports.prototype.saveSettings = function saveSettings(doPersist) {
    try {
      // Don't save settings if we aren't supposed to be persisting them
      if (this.persistSettings !== true) return;

      // Ensure we can access local storage
      if (!exports.hasLocalStorage) {
        console.log('Warning: Cannot access local storage. Settings will not be saved.');
        return;
      }

      // Save settings
      if (this.authentications['PureCloud Auth'].accessToken) {
        localStorage.setItem(`${this.settingsPrefix}_access_token`, this.authentications['PureCloud Auth'].accessToken);
        console.log('Access token saved to local storage');
      } else {
        console.log('Access token cleared');
        localStorage.removeItem(`${this.settingsPrefix}_access_token`);
      }
    } catch (e) {
      console.error(e);
    }
  };

{{#emitJSDoc}}  /**
   * @description xxx
   * @param {string} xxx - (Optional, default false) xxx
   */
{{/emitJSDoc}}  exports.prototype.loadSettings = function loadSettings(doPersist) {
    // Don't load settings if we aren't supposed to be persisting them
    if (this.persistSettings !== true) return;

    // Ensure we can access local storage
    if (!exports.hasLocalStorage) {
      console.log('Warning: Cannot access local storage. Settings will not be loaded.');
      return;
    }

    var token = localStorage.getItem(`${this.settingsPrefix}_access_token`);
    if (token) {
      this.setAccessToken(token);
      console.log('Access token retrieved from local storage');
    }
  };

{{#emitJSDoc}}  /**
   * @description Sets the environment used by the session
   * @param {string} environment - (Optional, default "mypurecloud.com") Environment the session use, e.g. mypurecloud.ie, mypurecloud.com.au, etc.
   */
{{/emitJSDoc}}  exports.prototype.setEnvironment = function setEnvironment(environment) {
    if (!environment)
      environment = 'mypurecloud.com';

    // Strip trailing slash
    environment = environment.replace(/\/+$/, '');

    // Strip protocol and subdomain
    if (environment.startsWith('https://'))
      environment = environment.substring(8);
    if (environment.startsWith('http://'))
      environment = environment.substring(7);
    if (environment.startsWith('api.'))
      environment = environment.substring(4);

    // Set vars
    this.environment = environment;
    this.basePath = `https://api.${environment}`;
    this.authUrl = `https://login.${environment}`;
  };

{{#emitJSDoc}}  /**
   * @description xxx
   * @param {xxxtypexxx} xxxnamexxx - (Optional, default "xxx") xxx
   */
{{/emitJSDoc}}  exports.prototype.loginImplicitGrant = function loginImplicitGrant(clientId, redirectUri) {
    var self = this;
    this.clientId = clientId;
    this.redirectUri = redirectUri;

    return new Promise(function(resolve, reject) {
      self._testTokenAccess()
        .then(function() {
          resolve();
        })
        .catch(function(error) {
          var query = {
              client_id: encodeURIComponent(self.clientId),
              redirect_uri: encodeURI(self.redirectUri),
              response_type: 'token'
          };

          var url = self._buildAuthUrl('oauth/authorize', query);
          console.log(`Implicit grant: redirecting to ${url} for authorization...`);
          window.location.replace(url);
        });
    });
  };

{{#emitJSDoc}}  /**
   * @description xxx
   * @param {xxxtypexxx} xxxnamexxx - (Optional, default "xxx") xxx
   */
{{/emitJSDoc}}  exports.prototype.loginClientCredentialsGrant = function(clientId, clientSecret) {
    //TODO
    throw new Error('Not implemented');
  };

{{#emitJSDoc}}  /**
   * @description xxx
   * @param {xxxtypexxx} xxxnamexxx - (Optional, default "xxx") xxx
   */
{{/emitJSDoc}}  exports.prototype._testTokenAccess = function _testTokenAccess() {
    var self = this;
    return new Promise(function(resolve, reject) {
      // Load from storage
      self.loadSettings();

      // Check if there is a token to test
      if (!self.authentications['PureCloud Auth'].accessToken) {
        reject(new Error('Token is not set'));
        return;
      }

      // Test token
      self.callApi('/api/v2/authorization/permissions', 'GET', 
        null, null, null, null, null, ['PureCloud Auth'], ['application/json'], ['application/json'])
        .then(function(roles) {
          self.saveSettings();
          resolve();
        })
        .catch(function(error) {
          self.setAccessToken(undefined);
          reject(error);
        });
    });
  };

{{#emitJSDoc}}  /**
   * @description xxx
   * @param {xxxtypexxx} xxxnamexxx - (Optional, default "xxx") xxx
   */
{{/emitJSDoc}}  exports.prototype._setValuesFromUrlHash = function() {
    // Check for window
    if(!(typeof window !== 'undefined' && window.location.hash)) return;

    // Process hash string into object
    var hash = window.location.hash
      .slice(1).split('&')
      .reduce(function(obj, pair) {
        var keyValue = pair.split('=');
        obj[keyValue[0]] = keyValue[1];
        return obj;
      }, {});

    // Set access token
    if(hash.access_token) {
      // Set access token
      this.setAccessToken(hash.access_token);

      // Remove hash from URL
      // Credit: https://stackoverflow.com/questions/1397329/how-to-remove-the-hash-from-window-location-with-javascript-without-page-refresh/5298684#5298684
      var scrollV, scrollH, loc = window.location;
      if ('replaceState' in history) {
        history.replaceState('', document.title, loc.pathname + loc.search);
      } else {
        // Prevent scrolling by storing the page's current scroll offset
        scrollV = document.body.scrollTop;
        scrollH = document.body.scrollLeft;

        // Remove hash
        loc.hash = '';

        // Restore the scroll offset, should be flicker free
        document.body.scrollTop = scrollV;
        document.body.scrollLeft = scrollH;
      }
    }
  };

{{#emitJSDoc}}  /**
   * @description xxx
   * @param {xxxtypexxx} xxxnamexxx - (Optional, default "xxx") xxx
   */
{{/emitJSDoc}}  exports.prototype.setAccessToken = function(token) {
    // Set token for API use
    this.authentications['PureCloud Auth'].accessToken = token;

    this.saveSettings();
  };

{{#emitJSDoc}}  /**
   * @description xxx
   * @param {xxxtypexxx} xxxnamexxx - (Optional, default "xxx") xxx
   */
{{/emitJSDoc}}  exports.prototype.setStorageKey = function(storageKey) {
    // Set storage key
    this.storageKey = storageKey;

    // Trigger storage of current token
    this.setAccessToken(this.authentications['PureCloud Auth'].accessToken);
  };

{{#emitJSDoc}}  /**
   * @description xxx
   * @param {xxxtypexxx} xxxnamexxx - (Optional, default "xxx") xxx
   */
{{/emitJSDoc}}  exports.hasLocalStorage = (function() {
    try {
      localStorage.setItem('purecloud_local_storage_test', 'purecloud_local_storage_test');
      localStorage.removeItem('purecloud_local_storage_test');
      return true;
    } catch(e) {
      return false;
    }
  }).call(this);

{{#emitJSDoc}}  /**
   * @description xxx
   * @param {xxxtypexxx} xxxnamexxx - (Optional, default "xxx") xxx
   */
{{/emitJSDoc}}  exports.prototype.logout = function() {
    if(exports.hasLocalStorage) {
        this.setAccessToken(null);
    }

    var query = {
        client_id: encodeURIComponent(this.clientId),
        redirect_uri: encodeURI(this.redirectUri)
    };

    var url = this._buildAuthUrl('logout', query);
    window.location.replace(url);
};

{{#emitJSDoc}}  /**
   * @description xxx
   * @param {xxxtypexxx} xxxnamexxx - (Optional, default "xxx") xxx
   */
{{/emitJSDoc}}  exports.prototype._buildAuthUrl = function(path, query) {
  function qs(url, key) {
      var val = query[key];
      if(!val) return url;
      return `${url}&${key}=${val}`;
  }

  if (!query) {
    query = {};
  }

  var baseUrl = `${this.authUrl}/${path}?`;
  return Object.keys(query).reduce(qs, baseUrl);
};

/////////////////////

{{#emitJSDoc}}  /**
   * Returns a string representation for an actual parameter.
   * @param param The actual parameter.
   * @returns {String} The string representation of <code>param</code>.
   */
{{/emitJSDoc}}  exports.prototype.paramToString = function(param) {
    if (param === undefined || param === null) {
      return '';
    }
    if (param instanceof Date) {
      return param.toJSON();
    }
    return param.toString();
  };

{{#emitJSDoc}}  /**
   * Builds full URL by appending the given path to the base URL and replacing path parameter place-holders with parameter values.
   * NOTE: query parameters are not handled here.
   * @param {String} path The path to append to the base URL.
   * @param {Object} pathParams The parameter values to append.
   * @returns {String} The encoded path with parameter values substituted.
   */
{{/emitJSDoc}}  exports.prototype.buildUrl = function(path, pathParams) {
    if (!path.match(/^\//)) {
      path = '/' + path;
    }
    var url = this.basePath + path;
    var _this = this;
    url = url.replace(/\{([\w-]+)\}/g, function(fullMatch, key) {
      var value;
      if (pathParams.hasOwnProperty(key)) {
        value = _this.paramToString(pathParams[key]);
      } else {
        value = fullMatch;
      }
      return encodeURIComponent(value);
    });
    return url;
  };

{{#emitJSDoc}}  /**
   * Checks whether the given content type represents JSON.<br>
   * JSON content type examples:<br>
   * <ul>
   * <li>application/json</li>
   * <li>application/json; charset=UTF8</li>
   * <li>APPLICATION/JSON</li>
   * </ul>
   * @param {String} contentType The MIME content type to check.
   * @returns {Boolean} <code>true</code> if <code>contentType</code> represents JSON, otherwise <code>false</code>.
   */
{{/emitJSDoc}}  exports.prototype.isJsonMime = function(contentType) {
    return Boolean(contentType !== null && contentType.match(/^application\/json(;.*)?$/i));
  };

{{#emitJSDoc}}  /**
   * Chooses a content type from the given array, with JSON preferred; i.e. return JSON if included, otherwise return the first.
   * @param {Array.<String>} contentTypes
   * @returns {String} The chosen content type, preferring JSON.
   */
{{/emitJSDoc}}  exports.prototype.jsonPreferredMime = function(contentTypes) {
    for (var i = 0; i < contentTypes.length; i++) {
      if (this.isJsonMime(contentTypes[i])) {
        return contentTypes[i];
      }
    }
    return contentTypes[0];
  };

{{#emitJSDoc}}  /**
   * Checks whether the given parameter value represents file-like content.
   * @param param The parameter to check.
   * @returns {Boolean} <code>true</code> if <code>param</code> represents a file. 
   */
{{/emitJSDoc}}  exports.prototype.isFileParam = function(param) {
    // fs.ReadStream in Node.js (but not in runtime like browserify)
    if (typeof window === 'undefined' &&
        typeof require === 'function' &&
        require('fs') &&
        param instanceof require('fs').ReadStream) {
      return true;
    }
    // Buffer in Node.js
    if (typeof Buffer === 'function' && param instanceof Buffer) {
      return true;
    }
    // Blob in browser
    if (typeof Blob === 'function' && param instanceof Blob) {
      return true;
    }
    // File in browser (it seems File object is also instance of Blob, but keep this for safe)
    if (typeof File === 'function' && param instanceof File) {
      return true;
    }
    return false;
  };

{{#emitJSDoc}}  /**
   * Normalizes parameter values:
   * <ul>
   * <li>remove nils</li>
   * <li>keep files and arrays</li>
   * <li>format to string with `paramToString` for other cases</li>
   * </ul>
   * @param {Object.<String, Object>} params The parameters as object properties.
   * @returns {Object.<String, Object>} normalized parameters.
   */
{{/emitJSDoc}}  exports.prototype.normalizeParams = function(params) {
    var newParams = {};
    for (var key in params) {
      if (params.hasOwnProperty(key) && params[key] !== undefined && params[key] !== null) {
        var value = params[key];
        if (this.isFileParam(value) || Array.isArray(value)) {
          newParams[key] = value;
        } else {
          newParams[key] = this.paramToString(value);
        }
      }
    }
    return newParams;
  };

{{#emitJSDoc}}  /**
   * Enumeration of collection format separator strategies.
   * @enum {String} 
   * @readonly
   */
  exports.CollectionFormatEnum = {
    /**
     * Comma-separated values. Value: <code>csv</code>
     * @const
     */
    CSV: ',',
    /**
     * Space-separated values. Value: <code>ssv</code>
     * @const
     */
    SSV: ' ',
    /**
     * Tab-separated values. Value: <code>tsv</code>
     * @const
     */
    TSV: '\t',
    /**
     * Pipe(|)-separated values. Value: <code>pipes</code>
     * @const
     */
    PIPES: '|',
    /**
     * Native array. Value: <code>multi</code>
     * @const
     */
    MULTI: 'multi'
  };

  /**
   * Builds a string representation of an array-type actual parameter, according to the given collection format.
   * @param {Array} param An array parameter.
   * @param {module:{{#invokerPackage}}{{invokerPackage}}/{{/invokerPackage}}ApiClient.CollectionFormatEnum} collectionFormat The array element separator strategy.
   * @returns {String|Array} A string representation of the supplied collection, using the specified delimiter. Returns
   * <code>param</code> as is if <code>collectionFormat</code> is <code>multi</code>.
   */
{{/emitJSDoc}}  exports.prototype.buildCollectionParam = function buildCollectionParam(param, collectionFormat) {
    if (param === null) {
      return null;
    }
    switch (collectionFormat) {
      case 'csv':
        return param.map(this.paramToString).join(',');
      case 'ssv':
        return param.map(this.paramToString).join(' ');
      case 'tsv':
        return param.map(this.paramToString).join('\t');
      case 'pipes':
        return param.map(this.paramToString).join('|');
      case 'multi':
        // return the array directly as SuperAgent will handle it as expected
        return param.map(this.paramToString);
      default:
        throw new Error('Unknown collection format: ' + collectionFormat);
    }
  };

{{#emitJSDoc}}  /**
   * Applies authentication headers to the request.
   * @param {Object} request The request object created by a <code>superagent()</code> call.
   * @param {Array.<String>} authNames An array of authentication method names.
   */
{{/emitJSDoc}}  exports.prototype.applyAuthToRequest = function(request, authNames) {
    var _this = this;
    authNames.forEach(function(authName) {
      var auth = _this.authentications[authName];
      switch (auth.type) {
        case 'basic':
          if (auth.username || auth.password) {
            request.auth(auth.username || '', auth.password || '');
          }
          break;
        case 'apiKey':
          if (auth.apiKey) {
            var data = {};
            if (auth.apiKeyPrefix) {
              data[auth.name] = auth.apiKeyPrefix + ' ' + auth.apiKey;
            } else {
              data[auth.name] = auth.apiKey;
            }
            if (auth['in'] === 'header') {
              request.set(data);
            } else {
              request.query(data);
            }
          }
          break;
        case 'oauth2':
          if (auth.accessToken) {
            request.set({'Authorization': 'Bearer ' + auth.accessToken});
          }
          break;
        default:
          throw new Error('Unknown authentication type: ' + auth.type);
      }
    });
  };

{{#emitJSDoc}}{{^usePromises}}  /**
   * Callback function to receive the result of the operation.
   * @callback module:{{#invokerPackage}}{{invokerPackage}}/{{/invokerPackage}}ApiClient~callApiCallback
   * @param {String} error Error message, if any.
   * @param data The data returned by the service call.
   * @param {String} response The complete HTTP response.
   */

{{/usePromises}}  /**
   * Invokes the REST service using the supplied settings and parameters.
   * @param {String} path The base URL to invoke.
   * @param {String} httpMethod The HTTP method to use.
   * @param {Object.<String, String>} pathParams A map of path parameters and their values.
   * @param {Object.<String, Object>} queryParams A map of query parameters and their values.
   * @param {Object.<String, Object>} headerParams A map of header parameters and their values.
   * @param {Object.<String, Object>} formParams A map of form parameters and their values.
   * @param {Object} bodyParam The value to pass as the request body.
   * @param {Array.<String>} authNames An array of authentication type names.
   * @param {Array.<String>} contentTypes An array of request MIME types.
   * @param {Array.<String>} accepts An array of acceptable response MIME types.types or the
   * constructor for a complex type.{{^usePromises}}
   * @param {module:{{#invokerPackage}}{{invokerPackage}}/{{/invokerPackage}}ApiClient~callApiCallback} callback The callback function.
{{/usePromises}}   * @returns {{#usePromises}}{Promise} A Promise object{{/usePromises}}{{^usePromises}}{Object} The SuperAgent request object{{/usePromises}}.
   */
{{/emitJSDoc}}  exports.prototype.callApi = function callApi(path, httpMethod, pathParams,
      queryParams, headerParams, formParams, bodyParam, authNames, contentTypes, accepts{{^usePromises}}, callback{{/usePromises}}) {

    var _this = this;
    var url = this.buildUrl(path, pathParams);
    var request = superagent(httpMethod, url);

    if(this.debugLog){
      var trace = `[REQUEST] ${httpMethod} ${url}`;
      if(pathParams && Object.keys(pathParams).count > 0 && pathParams[Object.keys(pathParams)[0]]){
        trace += "\nPath Params: " + JSON.stringify(pathParams);
      }

      if(queryParams && Object.keys(queryParams).count > 0 && queryParams[Object.keys(queryParams)[0]]){
        trace += "\nQuery Params: " + JSON.stringify(queryParams);
      }

      if(bodyParam){
        trace += "\nBody: " + JSON.stringify(bodyParam);
      }

      this.debugLog(trace);
    }

    // apply authentications
    this.applyAuthToRequest(request, authNames);

    // set query parameters
    request.query(this.normalizeParams(queryParams));

    // set header parameters
    request.set(this.defaultHeaders).set(this.normalizeParams(headerParams));

    // set request timeout
    request.timeout(this.timeout);

    var contentType = this.jsonPreferredMime(contentTypes);
    if (contentType) {
      request.type(contentType);
    } else if (!request.header['Content-Type']) {
      request.type('application/json');
    }

    if (contentType === 'application/x-www-form-urlencoded') {
      request.send(this.normalizeParams(formParams));
    } else if (contentType == 'multipart/form-data') {
      var _formParams = this.normalizeParams(formParams);
      for (var key in _formParams) {
        if (_formParams.hasOwnProperty(key)) {
          if (this.isFileParam(_formParams[key])) {
            // file field
            request.attach(key, _formParams[key]);
          } else {
            request.field(key, _formParams[key]);
          }
        }
      }
    } else if (bodyParam) {
      request.send(bodyParam);
    }

    var accept = this.jsonPreferredMime(accepts);
    if (accept) {
      request.accept(accept);
    }

{{#usePromises}}    return new Promise(function(resolve, reject) {
      request.end(function(error, response) {

        // Build response object
        var data = (_this.returnExtended === true || error) ? {
              status: response.status,
              statusText: response.statusText,
              headers: response.headers,
              body: response.body,
              text: response.text,
              error: error
            } : response.body ? response.body : response.text;

        // Debug logging
        if (_this.debugLog) {
          var trace = `[RESPONSE] ${response.status}: ${httpMethod} ${url}`;
          if (response.headers)
            trace += `\ninin-correlation-id: ${response.headers['inin-correlation-id']}`;
          if (response.body)
            trace += `\nBody: ${JSON.stringify(response.body,null,2)}`;

          // Truncate to 25 lines
          var truncTrace = '';
          var lines = trace.split('\n');
          if (lines.length > 25) {
            for  (var i = 0; i < 25; i++) {
              truncTrace += lines[i] + '\n';
            }
            truncTrace += '...response truncated...';
            trace = truncTrace;
          }

          // Log trace message
          _this.debugLog(trace);

          // Log stack trace
          if (error)
            _this.debugLog(error);
        }

        // Resolve promise
        if (error) {
          reject(data);
        } else {
          resolve(data);
        }
      });
    });{{/usePromises}}
{{^usePromises}}    request.end(function(error, response) {
      if (callback) {
        // Get the parsed body
        var data = response.body;

        // Fall back to the string body
        if (!data)
          data = response.text;
        callback(error, data, response);
      }
    });

    return request;
{{/usePromises}}  };

{{#emitJSDoc}}  /**
   * Parses an ISO-8601 string representation of a date value.
   * @param {String} str The date value as a string.
   * @returns {Date} The parsed date object.
   */
{{/emitJSDoc}}  exports.parseDate = function(str) {
    return new Date(str.replace(/T/i, ' '));
  };

{{#emitJSDoc}}  /**
   * The default API client implementation.
   * @type {module:{{#invokerPackage}}{{invokerPackage}}/{{/invokerPackage}}ApiClient}
   */
{{/emitJSDoc}}  exports.instance = new exports();

  return exports;
}));
