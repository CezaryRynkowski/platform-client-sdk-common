package {{packageName}}

import (
	"encoding/json"
	"fmt"
	"github.com/tidwall/pretty"
	"io"
	"log"
	"net/http"
	"os"
	"strconv"
	"strings"
	"time"
)

var (
	traceLogger *log.Logger
	debugLogger *log.Logger
	errorLogger *log.Logger
)

type LoggingLevel int

const (
	LTrace LoggingLevel = iota
	LDebug
	LError
	LNone
)

type LoggingFormat int

const (
	JSON LoggingFormat = iota
	Text
)

type logStatement struct {
	Date            *time.Time  `json:"date,omitempty"`
	Method          string      `json:"method,omitempty"`
	URL             string      `json:"url,omitempty"`
	RequestHeaders  http.Header `json:"requestHeaders,omitempty"`
	ResponseHeaders http.Header `json:"responseHeaders,omitempty"`
	CorrelationId   string      `json:"correlationId,omitempty"`
	StatusCode      int         `json:"statusCode,omitempty"`
	RequestBody     string      `json:"requestBody,omitempty"`
	ResponseBody    string      `json:"responseBody,omitempty"`
}

func (s *logStatement) string(format LoggingFormat) string {
	if len(s.RequestHeaders["Authorization"]) > 0 {
		s.RequestHeaders["Authorization"] = []string{"[REDACTED]"}
	}

	if format == Text {
		return fmt.Sprintf(`
=== REQUEST ===%v%v%v%v
=== RESPONSE ===%v%v%v%v`,
	   formatValue("URL", s.URL),
	   formatValue("Method", s.Method),
	   formatValue("Headers", formatHeaders(s.RequestHeaders)),
	   formatValue("Body", s.RequestBody),

	   formatValue("Status", fmt.Sprintf("%v",s.StatusCode)),
	   formatValue("Headers", formatHeaders(s.ResponseHeaders)),
	   formatValue("CorrelationId", s.CorrelationId),
	   formatValue("Body", s.ResponseBody))
	}

	j, _ := json.Marshal(s)
	str, _ := strconv.Unquote(strings.Replace(strconv.Quote(string(j)), `\\u`, `\u`, -1))

	return strings.TrimRight(string(pretty.Pretty([]byte(str))), "\n")
}

func (c *LoggingConfiguration) configureLogging() {
	var f *os.File
	if c.LogFilePath != "" {
		// TODO Do we append or start fresh
		f, _ = os.OpenFile(c.LogFilePath , os.O_RDWR|os.O_CREATE|os.O_APPEND, 0666)
	}

	var stdoutWrt io.Writer
	var stderrWrt io.Writer

	if f != nil && c.LogToConsole { // Logging to console and file
		stdoutWrt = io.MultiWriter(f, os.Stdout)
		stderrWrt = io.MultiWriter(f, os.Stderr)
	} else if f == nil && c.LogToConsole { // Logging to console
		stdoutWrt = io.MultiWriter(os.Stdout)
		stderrWrt = io.MultiWriter(os.Stderr)
	} else if f != nil && !c.LogToConsole { // Logging to file
		stdoutWrt = io.MultiWriter(f)
		stderrWrt = io.MultiWriter(f)
	} else { // Cannot log to anything
		traceLogger = nil
		debugLogger = nil
		errorLogger = nil
		return
	}

	flags := log.Ldate | log.Ltime
	traceLogger = log.New(stdoutWrt, "TRACE: ", flags)
	debugLogger = log.New(stdoutWrt, "DEBUG: ", flags)
	errorLogger = log.New(stderrWrt, "ERROR: ", flags)
}

func (c *LoggingConfiguration) trace(method, URL string, requestBody []byte, statusCode int, requestHeaders, responseHeaders http.Header) {
	now := time.Now()
	logStatement := &logStatement{
		Date:           &now,
		Method:         method,
		URL:            URL,
		RequestBody:    string(requestBody),
		StatusCode:     statusCode,
		RequestHeaders: requestHeaders,
		ResponseHeaders: responseHeaders,
	}

	c.log(traceLogger, LTrace, logStatement.string(c.LogFormat))
}

func (c *LoggingConfiguration) debug(method, URL string, requestBody []byte, statusCode int, requestHeaders http.Header) {
	now := time.Now()
	logStatement := &logStatement{
		Date:           &now,
		Method:         method,
		URL:            URL,
		RequestBody:    string(requestBody),
		StatusCode:     statusCode,
		RequestHeaders: requestHeaders,
	}

	c.log(debugLogger, LDebug, logStatement.string(c.LogFormat))
}

func (c *LoggingConfiguration) error(method, URL string, requestBody, responseBody []byte, statusCode int, requestHeaders, responseHeaders http.Header) {
	now := time.Now()
	logStatement := &logStatement{
		&now,
		method,
		URL,
		requestHeaders,
		responseHeaders,
		getCorrelationId(responseHeaders),
		statusCode,
		string(requestBody),
		string(responseBody),
	}

	c.log(errorLogger, LError, logStatement.string(c.LogFormat))
}

func (c *LoggingConfiguration) log(logger *log.Logger, logLevel LoggingLevel, v ...interface{}) {
	if logLevel >= c.LogLevel && logger != nil {
		logger.Println(v...)
	}
}

func getCorrelationId(headers http.Header) string {
	for key, values := range headers {
		if strings.ToLower(key) == "inin-correlation-id" {
			for _, value := range values {
				if value != "" {
					return value
				}
			}
		}
	}

	return ""
}

// Returns each header key value pair indented by one tab
func formatHeaders(headers http.Header) string {
	var result string
	for key, values := range headers {
		var valuesString string
		for _, value := range values {
			valuesString = fmt.Sprintf("%v, %v", valuesString, value)
		}
		valuesString = strings.TrimLeft(valuesString, ", ")
		result = fmt.Sprintf("%v\n\t%v: %v", result, key, valuesString)
	}
	return result
}

// Used to only print values that aren't empty
func formatValue(name, value string) string {
	if value != "" {
		return fmt.Sprintf("\n%v: %v", name, value)
	}
	return ""
}
